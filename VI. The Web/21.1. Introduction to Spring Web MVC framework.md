Spring Web MVC 框架介绍
========================

Spring Web 模型-视图-控制器(MVC) 框架围绕 *DispatcherServlet* 而设计，DispatcherServlet可根据handler映射配置，分发请求到对应handler处理器，也支持视图解析，本地化、时区和主题的解析以及文件上传。默认 handler 使用 *@Controller* 和 *@RequestMapping* 注解,提供多种灵活的处理方法。在Spring 3.0 中引入了 @Controller 机制，允许你通过 *@PathVariable* 注解和其他功能来创建 RESTful web 站点和应用程序。

"对扩展开放。。。。。。" 是 Spring Web MVC 的关键设计原则之一，Spring 一般来说就是 "对扩展开放，对修改关闭"原则。

Spring Web MVC 核心类中一些方法被标为 final。作为开发者，你不能通过覆盖这些方法，来提供自定义行为。这不是任性，而是想强调这些原则。

这些原则的说明，请参考 Seth Ladd 等人所著一书Expert Spring Web MVC and Web ;特别是该书第一版 117 页 "A Look At Design" 的章节，又或者看一下：

(Bob Martin, The Open-Closed Principle \(PDF\))[http://www.objectmentor.com/resources/articles/ocp.pdf]

在你使用Spring MVC 时，你不能在final方法中添加advice。比如，你不能给 *AbstractController.setSynchronizeOnSession()* 添加 advice。欲了解更多AOP代理以及你为什么不能在final方法上添加advice的信息，请参考 章节 9.6.1, “Understanding AOP proxies”。

In Spring Web MVC you can use any object as a command or form-backing object; you do not need to implement a framework-specific interface or base class. Spring’s data binding is highly flexible: for example, it treats type mismatches as validation errors that can be evaluated by the application, not as system errors. Thus you do not need to duplicate your business objects' properties as simple, untyped strings in your form objects simply to handle invalid submissions, or to convert the Strings properly. Instead, it is often preferable to bind directly to your business objects.

Spring’s view resolution is extremely flexible. A Controller is typically responsible for preparing a model Map with data and selecting a view name but it can also write directly to the response stream and complete the request. View name resolution is highly configurable through file extension or Accept header content type negotiation, through bean names, a properties file, or even a custom ViewResolver implementation. The model (the M in MVC) is a Map interface, which allows for the complete abstraction of the view technology. You can integrate directly with template based rendering technologies such as JSP, Velocity and Freemarker, or directly generate XML, JSON, Atom, and many other types of content. The model Map is simply transformed into an appropriate format, such as JSP request attributes, a Velocity template model.

